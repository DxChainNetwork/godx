
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DxChainNetwork/godx/common/bytes.go (0.0%)</option>
				
				<option value="file1">github.com/DxChainNetwork/godx/common/debug.go (0.0%)</option>
				
				<option value="file2">github.com/DxChainNetwork/godx/common/format.go (0.0%)</option>
				
				<option value="file3">github.com/DxChainNetwork/godx/common/json.go (74.7%)</option>
				
				<option value="file4">github.com/DxChainNetwork/godx/common/path.go (0.0%)</option>
				
				<option value="file5">github.com/DxChainNetwork/godx/common/size.go (0.0%)</option>
				
				<option value="file6">github.com/DxChainNetwork/godx/common/test_utils.go (0.0%)</option>
				
				<option value="file7">github.com/DxChainNetwork/godx/common/types.go (4.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

// Package common contains various helper functions.
package common

import "encoding/hex"

// ToHex returns the hex representation of b, prefixed with '0x'.
// For empty slices, the return value is "0x0".
//
// Deprecated: use hexutil.Encode instead.
func ToHex(b []byte) string <span class="cov0" title="0">{
        hex := Bytes2Hex(b)
        if len(hex) == 0 </span><span class="cov0" title="0">{
                hex = "0"
        }</span>
        <span class="cov0" title="0">return "0x" + hex</span>
}

// ToHexArray creates a array of hex-string based on []byte
func ToHexArray(b [][]byte) []string <span class="cov0" title="0">{
        r := make([]string, len(b))
        for i := range b </span><span class="cov0" title="0">{
                r[i] = ToHex(b[i])
        }</span>
        <span class="cov0" title="0">return r</span>
}

// FromHex returns the bytes represented by the hexadecimal string s.
// s may be prefixed with "0x".
func FromHex(s string) []byte <span class="cov0" title="0">{
        if len(s) &gt; 1 </span><span class="cov0" title="0">{
                if s[0:2] == "0x" || s[0:2] == "0X" </span><span class="cov0" title="0">{
                        s = s[2:]
                }</span>
        }
        <span class="cov0" title="0">if len(s)%2 == 1 </span><span class="cov0" title="0">{
                s = "0" + s
        }</span>
        <span class="cov0" title="0">return Hex2Bytes(s)</span>
}

// CopyBytes returns an exact copy of the provided bytes.
func CopyBytes(b []byte) (copiedBytes []byte) <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">copiedBytes = make([]byte, len(b))
        copy(copiedBytes, b)

        return</span>
}

// hasHexPrefix validates str begins with '0x' or '0X'.
func hasHexPrefix(str string) bool <span class="cov0" title="0">{
        return len(str) &gt;= 2 &amp;&amp; str[0] == '0' &amp;&amp; (str[1] == 'x' || str[1] == 'X')
}</span>

// isHexCharacter returns bool of c being a valid hexadecimal.
func isHexCharacter(c byte) bool <span class="cov0" title="0">{
        return ('0' &lt;= c &amp;&amp; c &lt;= '9') || ('a' &lt;= c &amp;&amp; c &lt;= 'f') || ('A' &lt;= c &amp;&amp; c &lt;= 'F')
}</span>

// isHex validates whether each byte is valid hexadecimal string.
func isHex(str string) bool <span class="cov0" title="0">{
        if len(str)%2 != 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, c := range []byte(str) </span><span class="cov0" title="0">{
                if !isHexCharacter(c) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Bytes2Hex returns the hexadecimal encoding of d.
func Bytes2Hex(d []byte) string <span class="cov0" title="0">{
        return hex.EncodeToString(d)
}</span>

// Hex2Bytes returns the bytes represented by the hexadecimal string str.
func Hex2Bytes(str string) []byte <span class="cov0" title="0">{
        h, _ := hex.DecodeString(str)
        return h
}</span>

// Hex2BytesFixed returns bytes of a specified fixed length flen.
func Hex2BytesFixed(str string, flen int) []byte <span class="cov0" title="0">{
        h, _ := hex.DecodeString(str)
        if len(h) == flen </span><span class="cov0" title="0">{
                return h
        }</span>
        <span class="cov0" title="0">if len(h) &gt; flen </span><span class="cov0" title="0">{
                return h[len(h)-flen:]
        }</span>
        <span class="cov0" title="0">hh := make([]byte, flen)
        copy(hh[flen-len(h):flen], h)
        return hh</span>
}

// RightPadBytes zero-pads slice to the right up to length l.
func RightPadBytes(slice []byte, l int) []byte <span class="cov0" title="0">{
        if l &lt;= len(slice) </span><span class="cov0" title="0">{
                return slice
        }</span>

        <span class="cov0" title="0">padded := make([]byte, l)
        copy(padded, slice)

        return padded</span>
}

// LeftPadBytes zero-pads slice to the left up to length l.
func LeftPadBytes(slice []byte, l int) []byte <span class="cov0" title="0">{
        if l &lt;= len(slice) </span><span class="cov0" title="0">{
                return slice
        }</span>

        <span class="cov0" title="0">padded := make([]byte, l)
        copy(padded[l-len(slice):], slice)

        return padded</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "fmt"
        "os"
        "runtime"
        "runtime/debug"
        "strings"
)

// Report gives off a warning requesting the user to submit an issue to the github tracker.
func Report(extra ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintln(os.Stderr, "You've encountered a sought after, hard to reproduce bug. Please report this to the developers &lt;3 https://github.com/DxChainNetwork/godx/issues")
        fmt.Fprintln(os.Stderr, extra...)

        _, file, line, _ := runtime.Caller(1)
        fmt.Fprintf(os.Stderr, "%v:%v\n", file, line)

        debug.PrintStack()

        fmt.Fprintln(os.Stderr, "#### BUG! PLEASE REPORT ####")
}</span>

// PrintDepricationWarning prinst the given string in a box using fmt.Println.
func PrintDepricationWarning(str string) <span class="cov0" title="0">{
        line := strings.Repeat("#", len(str)+4)
        emptyLine := strings.Repeat(" ", len(str))
        fmt.Printf(`
%s
# %s #
# %s #
# %s #
%s

`, line, emptyLine, str, emptyLine, line)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "fmt"
        "regexp"
        "strings"
        "time"
)

// PrettyDuration is a pretty printed version of a time.Duration value that cuts
// the unnecessary precision off from the formatted textual representation.
type PrettyDuration time.Duration

var prettyDurationRe = regexp.MustCompile(`\.[0-9]+`)

// String implements the Stringer interface, allowing pretty printing of duration
// values rounded to three decimals.
func (d PrettyDuration) String() string <span class="cov0" title="0">{
        label := fmt.Sprintf("%v", time.Duration(d))
        if match := prettyDurationRe.FindString(label); len(match) &gt; 4 </span><span class="cov0" title="0">{
                label = strings.Replace(label, match, match[:4], 1)
        }</span>
        <span class="cov0" title="0">return label</span>
}

// PrettyAge is a pretty printed version of a time.Duration value that rounds
// the values up to a single most significant unit, days/weeks/years included.
type PrettyAge time.Time

// ageUnits is a list of units the age pretty printing uses.
var ageUnits = []struct {
        Size   time.Duration
        Symbol string
}{
        {12 * 30 * 24 * time.Hour, "y"},
        {30 * 24 * time.Hour, "mo"},
        {7 * 24 * time.Hour, "w"},
        {24 * time.Hour, "d"},
        {time.Hour, "h"},
        {time.Minute, "m"},
        {time.Second, "s"},
}

// String implements the Stringer interface, allowing pretty printing of duration
// values rounded to the most significant time unit.
func (t PrettyAge) String() string <span class="cov0" title="0">{
        // Calculate the time difference and handle the 0 cornercase
        diff := time.Since(time.Time(t))
        if diff &lt; time.Second </span><span class="cov0" title="0">{
                return "0"
        }</span>
        // Accumulate a precision of 3 components before returning
        <span class="cov0" title="0">result, prec := "", 0

        for _, unit := range ageUnits </span><span class="cov0" title="0">{
                if diff &gt; unit.Size </span><span class="cov0" title="0">{
                        result = fmt.Sprintf("%s%d%s", result, diff/unit.Size, unit.Symbol)
                        diff %= unit.Size

                        if prec += 1; prec &gt;= 3 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package common

import (
        "bytes"
        "encoding/json"
        "errors"
        "golang.org/x/crypto/sha3"
        "io/ioutil"
        "os"
        "strings"
        "sync"
)

const (
        tempSuffix         = "_temp" // temporary file suffix
        jsonHashValSize    = 69      // quote + 64 byte hash + "0x" + quote + \n
        jsonManualHashSize = 9       // quote + len("manual") + quote + \n
)

// Error Collection
var (
        ErrBadFilenameSuffix = errors.New("filename suffix '_temp' is not allowed")
        ErrFileInUse         = errors.New("another routine is saving or loading this file")
        ErrBadHeader         = errors.New("wrong header")
        ErrBadVersion        = errors.New("incompatible file version")
        ErrFileOpen          = errors.New("failed to open the file")
        ErrBadHash           = errors.New("hashVal -- loading file with bad hash value")
        ErrCorrupted         = errors.New("failed to read the JSON file from the disk: hashVal -- loading file with bad hash value")
)

var (
        activeFiles   = make(map[string]struct{})
        activeFilesMu sync.Mutex
)

// Metadata defines the data file header and version
type Metadata struct {
        Header, Version string
}

// LoadJSONCompat reads the given file and unmarshal its content. It adds compatibility comparing to original file
func LoadJSONCompat(meta Metadata, filename string, val interface{}) error <span class="cov8" title="1">{
        // validate file name and whether the file is occupied
        err := fileValidation(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // remove the file from the list
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                activeFilesMu.Lock()
                delete(activeFiles, filename)
                activeFilesMu.Unlock()
        }</span>()

        <span class="cov8" title="1">err = readJSON(meta, filename, val)

        if err == ErrBadHeader || err == ErrBadVersion || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        // try to read from the temp file
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                err := readJSON(meta, filename+tempSuffix, val)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.New("failed to read the JSON file from the disk: " + err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func readJSON(meta Metadata, filename string, val interface{}) error <span class="cov8" title="1">{
        // open the file
        file, err := os.Open(filename)

        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return ErrFileOpen
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Read the metadata from the file
        var header, version string
        dec := json.NewDecoder(file)
        if err := dec.Decode(&amp;header); err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to read the header from the file: " + err.Error())
        }</span>
        <span class="cov8" title="1">if header != meta.Header </span><span class="cov0" title="0">{
                return ErrBadHeader
        }</span>

        <span class="cov8" title="1">if err := dec.Decode(&amp;version); err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to read the version from the file: " + err.Error())
        }</span>
        <span class="cov8" title="1">if version != meta.Version </span><span class="cov0" title="0">{
                return ErrBadVersion
        }</span>

        // read the rest of data from the decoder buffer
        <span class="cov8" title="1">remaining, err := ioutil.ReadAll(dec.Buffered())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to read the rest of data from the file: " + err.Error())
        }</span>

        // double check if all data from the files are read
        <span class="cov8" title="1">extra, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to read the rest of data from the file: " + err.Error())
        }</span>
        <span class="cov8" title="1">remaining = append(remaining, extra...)

        checkManual := len(remaining) &gt;= jsonManualHashSize
        if len(remaining) &gt;= jsonHashValSize </span><span class="cov8" title="1">{
                var hashVal Hash
                err = json.Unmarshal(remaining[:jsonHashValSize], &amp;hashVal)
                checkManual = err != nil
                if err == nil &amp;&amp; hashVal.String() != dataHash(remaining[jsonHashValSize+1:]).String() </span><span class="cov8" title="1">{
                        return ErrBadHash
                }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                        remaining = remaining[jsonHashValSize+1:]
                }</span>
        }

        <span class="cov8" title="1">if checkManual </span><span class="cov8" title="1">{
                var manualHash string
                err := json.Unmarshal(remaining[:jsonManualHashSize], &amp;manualHash)
                if err == nil &amp;&amp; manualHash != "manual" </span><span class="cov0" title="0">{
                        return errors.New("manual -- loading file with bad hash value")
                }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                        remaining = remaining[jsonManualHashSize+1:]
                }</span>
        }

        // load the rest of data
        <span class="cov8" title="1">return json.Unmarshal(remaining, &amp;val)</span>
}

// SaveJSONCompat saves the metadata, data hash, and data into a file ended with .json
// and .json_temp
func SaveJSONCompat(meta Metadata, filename string, val interface{}) error <span class="cov8" title="1">{
        // validate file name and whether the file is occupied
        err := fileValidation(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // remove the file from the list
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                activeFilesMu.Lock()
                delete(activeFiles, filename)
                activeFilesMu.Unlock()
        }</span>()

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        enc := json.NewEncoder(buf)

        // encode metadata into buffer
        if err := enc.Encode(meta.Header); err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to encode the metadata header: " + err.Error())
        }</span>
        <span class="cov8" title="1">if err := enc.Encode(meta.Version); err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to encode the metadata version: " + err.Error())
        }</span>

        // marshal the value
        <span class="cov8" title="1">valBytes, err := json.MarshalIndent(val, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to marshal the data: " + err.Error())
        }</span>

        // create hashVal, save it into buffer
        <span class="cov8" title="1">hashVal := dataHash(valBytes)

        if err := enc.Encode(hashVal); err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to encode the checksum: " + err.Error())
        }</span>

        // save the value into the buffer, transfer to byte slice
        <span class="cov8" title="1">buf.Write(valBytes)
        data := buf.Bytes()

        // write data to temp file if data integrity check passed
        if !verifyHash(filename) </span><span class="cov8" title="1">{
                err = writeFile(filename+tempSuffix, data)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("temp file --&gt; " + err.Error())
                }</span>
        }

        <span class="cov8" title="1">err = writeFile(filename, data)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("persist file --&gt; " + err.Error())
        }</span>

        <span class="cov8" title="1">return err</span>
}

// fileValidation validates the file name and checks whether the file is occupied
func fileValidation(filename string) error <span class="cov8" title="1">{
        // verify the filename do not have _temp as suffix
        if strings.HasSuffix(filename, tempSuffix) </span><span class="cov8" title="1">{
                return ErrBadFilenameSuffix
        }</span>

        <span class="cov8" title="1">activeFilesMu.Lock()
        defer activeFilesMu.Unlock()
        if _, exists := activeFiles[filename]; exists </span><span class="cov8" title="1">{
                return ErrFileInUse
        }</span>
        <span class="cov8" title="1">activeFiles[filename] = struct{}{}
        return nil</span>
}

// writeFile write the data into the file
func writeFile(filename string, data []byte) (ferr error) <span class="cov8" title="1">{
        // open / create file
        file, err := os.OpenFile(filename, os.O_RDWR|os.O_TRUNC|os.O_CREATE, 0600)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("failed to open the file: " + err.Error())
                return err
        }</span>

        // error encountered while closing the file
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeError := file.Close()
                if closeError != nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        ferr = errors.New(err.Error() + closeError.Error())
                }</span> else<span class="cov8" title="1"> if closeError != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        ferr = closeError
                }</span>
        }()

        // Write data into file and save it on the disk
        <span class="cov8" title="1">_, err = file.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("failed to write the file: " + err.Error())
                return err
        }</span>
        <span class="cov8" title="1">err = file.Sync()
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("failed to sync the file: " + err.Error())
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// verifyHash verifies whether the data hash is modified
func verifyHash(filename string) bool <span class="cov8" title="1">{
        // open the file
        file, err := os.Open(filename)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // acquire header and version of the file
        var header, version string
        dec := json.NewDecoder(file)
        if err := dec.Decode(&amp;header); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if err := dec.Decode(&amp;version); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // read the rest of the file from the buffer
        <span class="cov8" title="1">remaining, err := ioutil.ReadAll(dec.Buffered())
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // making sure all data from the file are acquired
        <span class="cov8" title="1">extra, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">remaining = append(remaining, extra...)

        // verify the hashVal
        var hashVal Hash
        if len(remaining) &gt;= jsonHashValSize </span><span class="cov8" title="1">{
                err = json.Unmarshal(remaining[:jsonHashValSize], &amp;hashVal)
                if err == nil </span><span class="cov8" title="1">{
                        return hashVal == dataHash(remaining[68:])
                }</span>
        }

        // hashVal verification failed, check the "manual"
        <span class="cov0" title="0">var manualHash string
        if len(remaining) &gt;= jsonManualHashSize </span><span class="cov0" title="0">{
                err = json.Unmarshal(remaining[:jsonManualHashSize], &amp;manualHash)
                if err == nil </span><span class="cov0" title="0">{
                        return manualHash == "manual"
                }</span>
        }

        // check if the data is valid JSON data
        <span class="cov0" title="0">return json.Valid(remaining)</span>
}

// dataHash hashes the object, used for data integrity check
func dataHash(data ...[]byte) (h Hash) <span class="cov8" title="1">{
        d := sha3.NewLegacyKeccak256()
        for _, b := range data </span><span class="cov8" title="1">{
                d.Write(b)
        }</span>
        <span class="cov8" title="1">d.Sum(h[:0])
        return h</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
)

// MakeName creates a node name that follows the ethereum convention
// for such names. It adds the operation system name and Go runtime version
// the name.
func MakeName(name, version string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/v%s/%s/%s", name, version, runtime.GOOS, runtime.Version())
}</span>

// FileExist checks if a file exists at filePath.
func FileExist(filePath string) bool <span class="cov0" title="0">{
        _, err := os.Stat(filePath)
        if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// AbsolutePath returns datadir + filename, or filename if it is absolute.
func AbsolutePath(datadir string, filename string) string <span class="cov0" title="0">{
        if filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return filename
        }</span>
        <span class="cov0" title="0">return filepath.Join(datadir, filename)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2014 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "fmt"
)

// StorageSize is a wrapper around a float value that supports user friendly
// formatting.
type StorageSize float64

// String implements the stringer interface.
func (s StorageSize) String() string <span class="cov0" title="0">{
        if s &gt; 1000000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f mB", s/1000000)
        }</span> else<span class="cov0" title="0"> if s &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2f kB", s/1000)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.2f B", s)
        }</span>
}

// TerminalString implements log.TerminalStringer, formatting a string for console
// output during logging.
func (s StorageSize) TerminalString() string <span class="cov0" title="0">{
        if s &gt; 1000000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fmB", s/1000000)
        }</span> else<span class="cov0" title="0"> if s &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.2fkB", s/1000)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.2fB", s)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
)

// LoadJSON reads the given file and unmarshals its content.
func LoadJSON(file string, val interface{}) error <span class="cov0" title="0">{
        content, err := ioutil.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(content, val); err != nil </span><span class="cov0" title="0">{
                if syntaxerr, ok := err.(*json.SyntaxError); ok </span><span class="cov0" title="0">{
                        line := findLine(content, syntaxerr.Offset)
                        return fmt.Errorf("JSON syntax error at %v:%v: %v", file, line, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("JSON unmarshal error in %v: %v", file, err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// findLine returns the line number for the given offset into data.
func findLine(data []byte, offset int64) (line int) <span class="cov0" title="0">{
        line = 1
        for i, r := range string(data) </span><span class="cov0" title="0">{
                if int64(i) &gt;= offset </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if r == '\n' </span><span class="cov0" title="0">{
                        line++
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see &lt;http://www.gnu.org/licenses/&gt;.

package common

import (
        "database/sql/driver"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math/big"
        "math/rand"
        "reflect"
        "strings"

        "github.com/DxChainNetwork/godx/common/hexutil"
        "golang.org/x/crypto/sha3"
)

// Lengths of hashes and addresses in bytes.
const (
        // HashLength is the expected length of the hash
        HashLength = 32
        // AddressLength is the expected length of the address
        AddressLength = 20
)

var (
        hashT    = reflect.TypeOf(Hash{})
        addressT = reflect.TypeOf(Address{})
)

// Hash represents the 32 byte Keccak256 hash of arbitrary data.
type Hash [HashLength]byte

// BytesToHash sets b to hash.
// If b is larger than len(h), b will be cropped from the left.
func BytesToHash(b []byte) Hash <span class="cov0" title="0">{
        var h Hash
        h.SetBytes(b)
        return h
}</span>

// BigToHash sets byte representation of b to hash.
// If b is larger than len(h), b will be cropped from the left.
func BigToHash(b *big.Int) Hash <span class="cov0" title="0">{ return BytesToHash(b.Bytes()) }</span>

// HexToHash sets byte representation of s to hash.
// If b is larger than len(h), b will be cropped from the left.
func HexToHash(s string) Hash <span class="cov0" title="0">{ return BytesToHash(FromHex(s)) }</span>

// Bytes gets the byte representation of the underlying hash.
func (h Hash) Bytes() []byte <span class="cov0" title="0">{ return h[:] }</span>

// Big converts a hash to a big integer.
func (h Hash) Big() *big.Int <span class="cov0" title="0">{ return new(big.Int).SetBytes(h[:]) }</span>

// Hex converts a hash to a hex string.
func (h Hash) Hex() string <span class="cov8" title="1">{ return hexutil.Encode(h[:]) }</span>

// TerminalString implements log.TerminalStringer, formatting a string for console
// output during logging.
func (h Hash) TerminalString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%x…%x", h[:3], h[29:])
}</span>

// String implements the stringer interface and is used also by the logger when
// doing full logging into a file.
func (h Hash) String() string <span class="cov8" title="1">{
        return h.Hex()
}</span>

// Format implements fmt.Formatter, forcing the byte slice to be formatted as is,
// without going through the stringer interface used for logging.
func (h Hash) Format(s fmt.State, c rune) <span class="cov0" title="0">{
        fmt.Fprintf(s, "%"+string(c), h[:])
}</span>

// UnmarshalText parses a hash in hex syntax.
func (h *Hash) UnmarshalText(input []byte) error <span class="cov0" title="0">{
        return hexutil.UnmarshalFixedText("Hash", input, h[:])
}</span>

// UnmarshalJSON parses a hash in hex syntax.
func (h *Hash) UnmarshalJSON(input []byte) error <span class="cov8" title="1">{
        return hexutil.UnmarshalFixedJSON(hashT, input, h[:])
}</span>

// MarshalText returns the hex representation of h.
func (h Hash) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        return hexutil.Bytes(h[:]).MarshalText()
}</span>

// SetBytes sets the hash to the value of b.
// If b is larger than len(h), b will be cropped from the left.
func (h *Hash) SetBytes(b []byte) <span class="cov0" title="0">{
        if len(b) &gt; len(h) </span><span class="cov0" title="0">{
                b = b[len(b)-HashLength:]
        }</span>

        <span class="cov0" title="0">copy(h[HashLength-len(b):], b)</span>
}

// Generate implements testing/quick.Generator.
func (h Hash) Generate(rand *rand.Rand, size int) reflect.Value <span class="cov0" title="0">{
        m := rand.Intn(len(h))
        for i := len(h) - 1; i &gt; m; i-- </span><span class="cov0" title="0">{
                h[i] = byte(rand.Uint32())
        }</span>
        <span class="cov0" title="0">return reflect.ValueOf(h)</span>
}

// Scan implements Scanner for database/sql.
func (h *Hash) Scan(src interface{}) error <span class="cov0" title="0">{
        srcB, ok := src.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("can't scan %T into Hash", src)
        }</span>
        <span class="cov0" title="0">if len(srcB) != HashLength </span><span class="cov0" title="0">{
                return fmt.Errorf("can't scan []byte of len %d into Hash, want %d", len(srcB), HashLength)
        }</span>
        <span class="cov0" title="0">copy(h[:], srcB)
        return nil</span>
}

// Value implements valuer for database/sql.
func (h Hash) Value() (driver.Value, error) <span class="cov0" title="0">{
        return h[:], nil
}</span>

// UnprefixedHash allows marshaling a Hash without 0x prefix.
type UnprefixedHash Hash

// UnmarshalText decodes the hash from hex. The 0x prefix is optional.
func (h *UnprefixedHash) UnmarshalText(input []byte) error <span class="cov0" title="0">{
        return hexutil.UnmarshalFixedUnprefixedText("UnprefixedHash", input, h[:])
}</span>

// MarshalText encodes the hash as hex.
func (h UnprefixedHash) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(hex.EncodeToString(h[:])), nil
}</span>

/////////// Address

// Address represents the 20 byte address of an Ethereum account.
type Address [AddressLength]byte

// BytesToAddress returns Address with value b.
// If b is larger than len(h), b will be cropped from the left.
func BytesToAddress(b []byte) Address <span class="cov0" title="0">{
        var a Address
        a.SetBytes(b)
        return a
}</span>

// BigToAddress returns Address with byte values of b.
// If b is larger than len(h), b will be cropped from the left.
func BigToAddress(b *big.Int) Address <span class="cov0" title="0">{ return BytesToAddress(b.Bytes()) }</span>

// HexToAddress returns Address with byte values of s.
// If s is larger than len(h), s will be cropped from the left.
func HexToAddress(s string) Address <span class="cov0" title="0">{ return BytesToAddress(FromHex(s)) }</span>

// IsHexAddress verifies whether a string can represent a valid hex-encoded
// Ethereum address or not.
func IsHexAddress(s string) bool <span class="cov0" title="0">{
        if hasHexPrefix(s) </span><span class="cov0" title="0">{
                s = s[2:]
        }</span>
        <span class="cov0" title="0">return len(s) == 2*AddressLength &amp;&amp; isHex(s)</span>
}

// Bytes gets the string representation of the underlying address.
func (a Address) Bytes() []byte <span class="cov0" title="0">{ return a[:] }</span>

// Big converts an address to a big integer.
func (a Address) Big() *big.Int <span class="cov0" title="0">{ return new(big.Int).SetBytes(a[:]) }</span>

// Hash converts an address to a hash by left-padding it with zeros.
func (a Address) Hash() Hash <span class="cov0" title="0">{ return BytesToHash(a[:]) }</span>

// Hex returns an EIP55-compliant hex string representation of the address.
func (a Address) Hex() string <span class="cov0" title="0">{
        unchecksummed := hex.EncodeToString(a[:])
        sha := sha3.NewLegacyKeccak256()
        sha.Write([]byte(unchecksummed))
        hash := sha.Sum(nil)

        result := []byte(unchecksummed)
        for i := 0; i &lt; len(result); i++ </span><span class="cov0" title="0">{
                hashByte := hash[i/2]
                if i%2 == 0 </span><span class="cov0" title="0">{
                        hashByte = hashByte &gt;&gt; 4
                }</span> else<span class="cov0" title="0"> {
                        hashByte &amp;= 0xf
                }</span>
                <span class="cov0" title="0">if result[i] &gt; '9' &amp;&amp; hashByte &gt; 7 </span><span class="cov0" title="0">{
                        result[i] -= 32
                }</span>
        }
        <span class="cov0" title="0">return "0x" + string(result)</span>
}

// String implements fmt.Stringer.
func (a Address) String() string <span class="cov0" title="0">{
        return a.Hex()
}</span>

// Format implements fmt.Formatter, forcing the byte slice to be formatted as is,
// without going through the stringer interface used for logging.
func (a Address) Format(s fmt.State, c rune) <span class="cov0" title="0">{
        fmt.Fprintf(s, "%"+string(c), a[:])
}</span>

// SetBytes sets the address to the value of b.
// If b is larger than len(a) it will panic.
func (a *Address) SetBytes(b []byte) <span class="cov0" title="0">{
        if len(b) &gt; len(a) </span><span class="cov0" title="0">{
                b = b[len(b)-AddressLength:]
        }</span>
        <span class="cov0" title="0">copy(a[AddressLength-len(b):], b)</span>
}

// MarshalText returns the hex representation of a.
func (a Address) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return hexutil.Bytes(a[:]).MarshalText()
}</span>

// UnmarshalText parses a hash in hex syntax.
func (a *Address) UnmarshalText(input []byte) error <span class="cov0" title="0">{
        return hexutil.UnmarshalFixedText("Address", input, a[:])
}</span>

// UnmarshalJSON parses a hash in hex syntax.
func (a *Address) UnmarshalJSON(input []byte) error <span class="cov0" title="0">{
        return hexutil.UnmarshalFixedJSON(addressT, input, a[:])
}</span>

// Scan implements Scanner for database/sql.
func (a *Address) Scan(src interface{}) error <span class="cov0" title="0">{
        srcB, ok := src.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("can't scan %T into Address", src)
        }</span>
        <span class="cov0" title="0">if len(srcB) != AddressLength </span><span class="cov0" title="0">{
                return fmt.Errorf("can't scan []byte of len %d into Address, want %d", len(srcB), AddressLength)
        }</span>
        <span class="cov0" title="0">copy(a[:], srcB)
        return nil</span>
}

// Value implements valuer for database/sql.
func (a Address) Value() (driver.Value, error) <span class="cov0" title="0">{
        return a[:], nil
}</span>

// UnprefixedAddress allows marshaling an Address without 0x prefix.
type UnprefixedAddress Address

// UnmarshalText decodes the address from hex. The 0x prefix is optional.
func (a *UnprefixedAddress) UnmarshalText(input []byte) error <span class="cov0" title="0">{
        return hexutil.UnmarshalFixedUnprefixedText("UnprefixedAddress", input, a[:])
}</span>

// MarshalText encodes the address as hex.
func (a UnprefixedAddress) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(hex.EncodeToString(a[:])), nil
}</span>

// MixedcaseAddress retains the original string, which may or may not be
// correctly checksummed
type MixedcaseAddress struct {
        addr     Address
        original string
}

// NewMixedcaseAddress constructor (mainly for testing)
func NewMixedcaseAddress(addr Address) MixedcaseAddress <span class="cov0" title="0">{
        return MixedcaseAddress{addr: addr, original: addr.Hex()}
}</span>

// NewMixedcaseAddressFromString is mainly meant for unit-testing
func NewMixedcaseAddressFromString(hexaddr string) (*MixedcaseAddress, error) <span class="cov0" title="0">{
        if !IsHexAddress(hexaddr) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Invalid address")
        }</span>
        <span class="cov0" title="0">a := FromHex(hexaddr)
        return &amp;MixedcaseAddress{addr: BytesToAddress(a), original: hexaddr}, nil</span>
}

// UnmarshalJSON parses MixedcaseAddress
func (ma *MixedcaseAddress) UnmarshalJSON(input []byte) error <span class="cov0" title="0">{
        if err := hexutil.UnmarshalFixedJSON(addressT, input, ma.addr[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(input, &amp;ma.original)</span>
}

// MarshalJSON marshals the original value
func (ma *MixedcaseAddress) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if strings.HasPrefix(ma.original, "0x") || strings.HasPrefix(ma.original, "0X") </span><span class="cov0" title="0">{
                return json.Marshal(fmt.Sprintf("0x%s", ma.original[2:]))
        }</span>
        <span class="cov0" title="0">return json.Marshal(fmt.Sprintf("0x%s", ma.original))</span>
}

// Address returns the address
func (ma *MixedcaseAddress) Address() Address <span class="cov0" title="0">{
        return ma.addr
}</span>

// String implements fmt.Stringer
func (ma *MixedcaseAddress) String() string <span class="cov0" title="0">{
        if ma.ValidChecksum() </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s [chksum ok]", ma.original)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s [chksum INVALID]", ma.original)</span>
}

// ValidChecksum returns true if the address has valid checksum
func (ma *MixedcaseAddress) ValidChecksum() bool <span class="cov0" title="0">{
        return ma.original == ma.addr.Hex()
}</span>

// Original returns the mixed-case input string
func (ma *MixedcaseAddress) Original() string <span class="cov0" title="0">{
        return ma.original
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
